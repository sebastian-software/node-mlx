import { describe, it, expect } from "vitest"
import { SwiftGenerator } from "../src/generator.js"
import { HFModelParser } from "../src/parser.js"

describe("SwiftGenerator", () => {
  describe("generate", () => {
    it("generates file header", () => {
      const generator = new SwiftGenerator("qwen2")
      const result = generator.generate([])

      expect(result).toContain("//  Qwen2.swift")
      expect(result).toContain("Auto-generated by hf2swift")
      expect(result).toContain("import Foundation")
      expect(result).toContain("import MLX")
      expect(result).toContain("import MLXFast")
      expect(result).toContain("import MLXNN")
    })

    it("generates helper functions", () => {
      const generator = new SwiftGenerator("qwen2")
      const result = generator.generate([])

      expect(result).toContain("qwen2ApplyRotaryPosEmb")
      expect(result).toContain("qwen2RotateHalf")
    })

    it("generates config from JSON", () => {
      const generator = new SwiftGenerator("test")
      const config = {
        hidden_size: 768,
        num_hidden_layers: 12,
        num_attention_heads: 12,
        intermediate_size: 3072,
        vocab_size: 32000
      }

      const result = generator.generate([], config)

      expect(result).toContain("public struct TestConfiguration")
      expect(result).toContain("public var hiddenSize: Int")
    })

    it("generates MLP module", () => {
      const source = `
class TestMLP(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.gate_proj = nn.Linear(config.hidden_size, config.intermediate_size, bias=False)
        self.up_proj = nn.Linear(config.hidden_size, config.intermediate_size, bias=False)
        self.down_proj = nn.Linear(config.intermediate_size, config.hidden_size, bias=False)
    def forward(self, x):
        return self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))
`
      const parser = new HFModelParser("test")
      const modules = parser.parse(source)
      const generator = new SwiftGenerator("test")
      const result = generator.generate(modules)

      expect(result).toContain("class TestMLP: Module")
      expect(result).toContain('@ModuleInfo(key: "gate_proj") var gateProj: Linear')
      expect(result).toContain("init(_ config: TestConfiguration)")
      expect(result).toContain("downProj(gelu(gateProj(x)) * upProj(x))")
    })

    it("generates attention module", () => {
      const source = `
class TestAttention(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.q_proj = nn.Linear(config.hidden_size, config.hidden_size)
        self.k_proj = nn.Linear(config.hidden_size, config.hidden_size)
        self.v_proj = nn.Linear(config.hidden_size, config.hidden_size)
        self.o_proj = nn.Linear(config.hidden_size, config.hidden_size)
    def forward(self, hidden_states, attention_mask=None):
        pass
`
      const parser = new HFModelParser("test")
      const modules = parser.parse(source)
      const generator = new SwiftGenerator("test")
      const result = generator.generate(modules)

      expect(result).toContain("class TestAttention: Module")
      expect(result).toContain("let numHeads: Int")
      expect(result).toContain("let numKVHeads: Int")
      expect(result).toContain("let scale: Float")
      expect(result).toContain("qProj(x).reshaped([B, L, numHeads, headDim])")
      expect(result).toContain("KV cache update")
    })

    it("generates RMSNorm module", () => {
      const source = `
class TestRMSNorm(nn.Module):
    def __init__(self, hidden_size, eps=1e-6):
        super().__init__()
        self.weight = nn.Parameter(torch.ones(hidden_size))
        self.eps = eps
    def forward(self, x):
        pass
`
      const parser = new HFModelParser("test")
      const modules = parser.parse(source)
      const generator = new SwiftGenerator("test")
      const result = generator.generate(modules)

      expect(result).toContain("class TestRMSNorm: Module")
      expect(result).toContain("let eps: Float")
      expect(result).toContain("let withScale: Bool")
      expect(result).toContain("rsqrt(variance + eps)")
    })

    it("generates decoder layer", () => {
      const source = `
class TestAttention(nn.Module):
    def __init__(self, config):
        self.q_proj = nn.Linear(10, 10)
    def forward(self, x):
        return x

class TestMLP(nn.Module):
    def __init__(self, config):
        self.gate_proj = nn.Linear(10, 10)
    def forward(self, x):
        return x

class TestDecoderLayer(nn.Module):
    def __init__(self, config, layer_idx=0):
        super().__init__()
        self.self_attn = TestAttention(config)
        self.mlp = TestMLP(config)
        self.input_layernorm = RMSNorm(config.hidden_size)
        self.post_attention_layernorm = RMSNorm(config.hidden_size)
    def forward(self, x, mask=None, cache=None):
        pass
`
      const parser = new HFModelParser("test")
      const modules = parser.parse(source)
      const generator = new SwiftGenerator("test")
      const result = generator.generate(modules)

      expect(result).toContain("class TestDecoderLayer: Module")
      expect(result).toContain("init(_ config: TestConfiguration, layerIdx: Int = 0)")
      expect(result).toContain("let normed = inputLayernorm(h)")
      expect(result).toContain("let attnOut = selfAttn(normed, mask: mask, cache: cache)")
      expect(result).toContain("h = h + attnOut")
      expect(result).toContain("let mlpOut = mlp(postNormed)")
    })

    it("generates model wrapper", () => {
      const source = `
class TestDecoderLayer(nn.Module):
    def __init__(self, config, layer_idx=0):
        pass
    def forward(self, x):
        return x
`
      const parser = new HFModelParser("test")
      const modules = parser.parse(source)
      const generator = new SwiftGenerator("test")
      const result = generator.generate(modules)

      expect(result).toContain("class TestModelInner: Module")
      expect(result).toContain("public class TestModel: Module, LLMModel")
      expect(result).toContain("public let vocabularySize: Int")
      expect(result).toContain("public let numLayers: Int")
      expect(result).toContain("public func sanitize(weights:")
    })

    it("sorts modules by dependency", () => {
      const source = `
class Inner(nn.Module):
    def __init__(self, config):
        pass
    def forward(self, x):
        return x

class Outer(nn.Module):
    def __init__(self, config):
        self.inner = Inner(config)
    def forward(self, x):
        return x
`
      const parser = new HFModelParser("test")
      const modules = parser.parse(source)
      const generator = new SwiftGenerator("test")
      const result = generator.generate(modules)

      // Inner should appear before Outer in the output
      const innerPos = result.indexOf("class Inner:")
      const outerPos = result.indexOf("class Outer:")
      expect(innerPos).toBeLessThan(outerPos)
    })

    it("skips ForCausalLM wrapper classes", () => {
      const source = `
class TestMLP(nn.Module):
    def __init__(self, config):
        self.fc = nn.Linear(10, 10)
    def forward(self, x):
        return x

class TestForCausalLM(PreTrainedModel):
    def __init__(self, config):
        self.model = TestModel(config)
    def forward(self, x):
        return x
`
      const parser = new HFModelParser("test")
      const modules = parser.parse(source)
      const generator = new SwiftGenerator("test")
      const result = generator.generate(modules)

      expect(result).toContain("class TestMLP: Module")
      expect(result).not.toContain("TestForCausalLM")
    })

    it("generates rotary embedding", () => {
      const source = `
class TestRotaryEmbedding(nn.Module):
    def __init__(self, dim, max_position_embeddings=2048, base=10000):
        super().__init__()
        self.dim = dim
    def forward(self, x, offset=0):
        pass
`
      const parser = new HFModelParser("test")
      const modules = parser.parse(source)
      const generator = new SwiftGenerator("test")
      const result = generator.generate(modules)

      expect(result).toContain("class TestRotaryEmbedding: Module")
      expect(result).toContain("let dim: Int")
      expect(result).toContain("let maxPositionEmbeddings: Int")
      expect(result).toContain("let base: Float")
      expect(result).toContain("return (cos(angles), sin(angles))")
    })
  })
})
